# -*- coding: utf-8 -*-
"""trial_for_light_curves_search.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n2x-sHQFSi6NaG5ac5_lHrC3huMyexmm
"""

!pip install lightkurve --quiet
import lightkurve as lk

from scipy.signal import savgol_filter
import matplotlib.pyplot as plt
import numpy as np
from lightkurve.periodogram import BoxLeastSquares
positive=["CP", "PC", "KP"]


def curves(name, label):
  search = lk.search_lightcurve('TIC '+str(name), mission='TESS', author='SPOC')
  if len(search) == 0:
    return [], []
  lc = search.download()
  lc = lc.remove_nans().normalize()
  trend = savgol_filter(lc.flux.value, window_length=301, polyorder=2)
  flux_flat = lc.flux.value / trend
  t, f = lc.time.value, flux_flat
  bls = BoxLeastSquares(t, f)
  periods = np.linspace(0.5, 20, 10000)  # buscar entre 0.5–20 días
  result = bls.power(periods, 0.05)
  best = np.argmax(result.power)
  period = result.period[best]
  t_fold = (t % period) / period
  order = np.argsort(t_fold)
  f = f[order]
  if label not in positive:
    label= 0
  else:
    label= 1
  return f, label

import pandas as pd
df = pd.read_csv("/content/TOI_2025.10.04_12.31.14.csv")
to_keep=["tid", "tfopwg_disp"]
counter=0
for column in df.columns.tolist():
  if column not in to_keep:
    df.drop(column, axis=1, inplace=True)

df_yes=df[df["tfopwg_disp"].isin(positive)]
df_no=df[~df["tfopwg_disp"].isin(positive)]
df_yes=df_yes.reset_index(drop=True)
df_no=df_no.reset_index(drop=True)

X = []
y = []
for i in range(20):
  curve, label = curves(df_yes["tid"][i], df_yes["tfopwg_disp"][i])
  if len(curve) == 0:
    continue
  X.append(curve)
  y.append(label)

for i in range(20):
  curve, label = curves(df_no["tid"][i], df_no["tfopwg_disp"][i])
  if len(curve) == 0:
    continue
  X.append(curve)
  y.append(label)

import numpy as np

# define la longitud deseada (ajústala según tus datos)
target_len = 2000

def pad_or_truncate(curve, length=target_len):
    curve = np.array(curve, dtype=np.float32)
    if len(curve) > length:
        return curve[:length]  # recorta
    else:
        # rellena con 1.0 (flujo promedio) o 0
        return np.pad(curve, (0, length - len(curve)), 'constant', constant_values=1.0)

# aplica a todas las curvas
X_fixed = [pad_or_truncate(x) for x in X]
X_fixed = np.array(X_fixed, dtype=np.float32)

y = np.array(y, dtype=np.float32)

print(X_fixed.shape, y.shape)

!pip install tensorflow --quiet

from tensorflow.keras import layers, models
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, roc_auc_score
import matplotlib.pyplot as plt
import tensorflow as tf

X_train, X_test, y_train, y_test = train_test_split(X_fixed, y, test_size=0.25, random_state=42, stratify=y)

model = models.Sequential([
    layers.Conv1D(32, 8, activation='relu', input_shape=(X_fixed.shape[1], 1)),
    layers.MaxPooling1D(2),
    layers.Conv1D(64, 8, activation='relu'),
    layers.GlobalAveragePooling1D(),
    layers.Dense(64, activation='relu'),
    layers.Dense(1, activation='sigmoid')
])

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
model.fit(X_train, y_train, epochs=50, batch_size=1, validation_data=(X_test, y_test))

y_pred = (model.predict(X_test) > 0.5).astype("int32")
print(classification_report(y_test, y_pred))